<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>01 叶子分类Tricks</title>
      <link href="/2022/11/21/01%20%E5%8F%B6%E5%AD%90%E5%88%86%E7%B1%BBTricks%20/"/>
      <url>/2022/11/21/01%20%E5%8F%B6%E5%AD%90%E5%88%86%E7%B1%BBTricks%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><h2 id="Sklearn"><a href="#Sklearn" class="headerlink" title="Sklearn"></a>Sklearn</h2><ol><li>预处理函数preprocessing</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing有很多个子函数，比如正态化数据，做one-hot-key等</span></span><br><span class="line">sex = pd.Series([<span class="string">&quot;male&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;male&quot;</span>])</span><br><span class="line"></span><br><span class="line">encoder = preprocessing.LabelEncoder()       <span class="comment">#获取一个LabelEncoder</span></span><br><span class="line"><span class="comment">#可用df[&#x27;label&#x27;].unique().to_list()获得标签类别</span></span><br><span class="line">model = encoder.fit([<span class="string">&quot;male&quot;</span>, <span class="string">&quot;female&quot;</span>])      <span class="comment">#训练LabelEncoder, 把male编码为0，female编码为1</span></span><br><span class="line">sex = model.transform(sex)                   <span class="comment">#使用训练好的LabelEncoder对原数据进行编码</span></span><br><span class="line"><span class="comment"># 得到[1 0 0 1 1]</span></span><br></pre></td></tr></table></figure><h2 id="CutMix"><a href="#CutMix" class="headerlink" title="CutMix"></a>CutMix</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cutmix.cutmix <span class="keyword">import</span> CutMix</span><br><span class="line"><span class="keyword">from</span> cutmix.utils <span class="keyword">import</span> CutMixCrossEntropyLoss</span><br><span class="line"></span><br><span class="line">train_loss_function = CutMixCrossEntropyLoss(<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#其内部实现如下:</span></span><br><span class="line">  <span class="comment"># Compute the accuracy for current batch.</span></span><br><span class="line">      <span class="comment"># acc = (logits.argmax(dim=-1) == labels).float().mean()</span></span><br><span class="line">      <span class="comment"># Record the loss and accuracy</span></span><br><span class="line">    </span><br><span class="line">trainloader = torch.utils.data.DataLoader(</span><br><span class="line">                      CutMix(TrainValidData(train_val_path, img_path, transform = train_transform),                               num_class=<span class="number">176</span>, beta=<span class="number">1.0</span>, prob=<span class="number">0.5</span>, num_mix=<span class="number">2</span>), </span><br><span class="line">                      batch_size=<span class="number">128</span>, sampler=train_subsampler, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#train_transform、train_subsampler变量如下:</span></span><br><span class="line">train_subsampler = torch.utils.data.SubsetRandomSampler(train_ids)</span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    <span class="comment"># 随机裁剪图像，所得图像为原始面积的0.08到1之间，高宽比在3/4和4/3之间。</span></span><br><span class="line">    <span class="comment"># 然后，缩放图像以创建224 x 224的新图像</span></span><br><span class="line">    transforms.RandomResizedCrop(<span class="number">224</span>, scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">3.0</span> / <span class="number">4.0</span>, <span class="number">4.0</span> / <span class="number">3.0</span>)),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    <span class="comment"># 随机更改亮度，对比度和饱和度</span></span><br><span class="line">    transforms.ColorJitter(brightness=<span class="number">0.4</span>, contrast=<span class="number">0.4</span>, saturation=<span class="number">0.4</span>),</span><br><span class="line">    <span class="comment"># 添加随机噪声</span></span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 标准化图像的每个通道</span></span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br></pre></td></tr></table></figure><h1 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h1><h2 id="Lr-scheduler"><a href="#Lr-scheduler" class="headerlink" title="Lr_scheduler"></a>Lr_scheduler</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> CosineAnnealingLR</span><br><span class="line"></span><br><span class="line">scheduler = CosineAnnealingLR(optimizer,T_max=<span class="number">10</span>)</span><br><span class="line">scheduler.step()</span><br></pre></td></tr></table></figure><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>图片增强: 随机剪裁、翻转、对比度和颜色调整、随机噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    <span class="comment"># 随机裁剪图像，所得图像为原始面积的0.08到1之间，高宽比在3/4和4/3之间。</span></span><br><span class="line">    <span class="comment"># 然后，缩放图像以创建224 x 224的新图像</span></span><br><span class="line">    transforms.RandomResizedCrop(<span class="number">224</span>, scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">3.0</span> / <span class="number">4.0</span>, <span class="number">4.0</span> / <span class="number">3.0</span>)),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    <span class="comment"># 随机更改亮度，对比度和饱和度</span></span><br><span class="line">    transforms.ColorJitter(brightness=<span class="number">0.4</span>, contrast=<span class="number">0.4</span>, saturation=<span class="number">0.4</span>),</span><br><span class="line">    <span class="comment"># 添加随机噪声</span></span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 标准化图像的每个通道</span></span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br><span class="line">val_test_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),</span><br><span class="line">    <span class="comment"># 从图像中心裁切224x224大小的图片</span></span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br></pre></td></tr></table></figure><h2 id="Ensemble"><a href="#Ensemble" class="headerlink" title="Ensemble"></a>Ensemble</h2><p>将数据通过多个不同的模型，以其最终在验证集上的正确率做权重分配，投票得出最终的submission</p><p>或者直接平均，要注意每个模型对数据的要求和敏感度。</p><h2 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h2><p>不光训练的时候K折验证，提交submission也要K折，以获得最平滑平均的正确率</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kf = KFold(n_splits=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kf.get_n_splits(X)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(kf)</span><br><span class="line">KFold(n_splits=<span class="number">2</span>, random_state=<span class="literal">None</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(X):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;TRAIN:&quot;</span>, train_index, <span class="string">&quot;TEST:&quot;</span>, test_index)</span><br><span class="line"><span class="meta">... </span>    X_train, X_test = X[train_index], X[test_index]</span><br><span class="line"><span class="meta">... </span>    y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">TRAIN: [<span class="number">2</span> <span class="number">3</span>] TEST: [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">TRAIN: [<span class="number">0</span> <span class="number">1</span>] TEST: [<span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>kfold.split()将返回一个训练索引集合，一个验证索引集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line">k_folds = <span class="number">5</span></span><br><span class="line">kfold = KFold(n_splits=k_folds, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#trainin：</span></span><br><span class="line"><span class="keyword">for</span> fold, (train_ids,valid_ids) <span class="keyword">in</span> <span class="built_in">enumerate</span>(kfold.split(train_val_dataset)):</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Code-Trick"><a href="#Code-Trick" class="headerlink" title="Code Trick"></a>Code Trick</h1><ol><li>固定随机种子seed</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seed_everything</span>(<span class="params">seed</span>):</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed(seed)</span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># LHY版本</span></span><br><span class="line">myseed = <span class="number">6666</span>  <span class="comment"># set a random seed for reproducibility</span></span><br><span class="line">torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">np.random.seed(myseed)      </span><br><span class="line">torch.manual_seed(myseed)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    torch.cuda.manual_seed_all(myseed)</span><br></pre></td></tr></table></figure><ol start="2"><li>查看模型信息summary</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchinfo <span class="keyword">import</span> summary</span><br><span class="line">summary(model)</span><br></pre></td></tr></table></figure><ol start="3"><li>模型的参数冷冻</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否要冻住模型的前面一些层</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_parameter_requires_grad</span>(<span class="params">model, feature_extracting</span>):</span><br><span class="line">    <span class="keyword">if</span> feature_extracting:</span><br><span class="line">        model = model</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">            param.requires_grad = <span class="literal">False</span>   <span class="comment"># 因为是全局变量，设置为false就会冻住</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ResNeSt模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnest_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = resnest50(pretrained=<span class="literal">True</span>)</span><br><span class="line">    set_parameter_requires_grad(model_ft, feature_extract)</span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><a href="https://www.kaggle.com/code/sheepwang/leaf-classification-eda-model">查看博主的论文inference</a></p><ol><li>EDA</li><li>Train trick</li></ol><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><h4 id="training-epoch"><a href="#training-epoch" class="headerlink" title="training epoch"></a><strong>training epoch</strong></h4><p><strong>可以换成LHY的不进步多少个循环再停止</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------------------------------------&#x27;</span>)</span><br><span class="line"><span class="comment">#使用sklearn分割数据集 #注意此处使用的特殊的数据集，kfold本质是对index处理</span></span><br><span class="line"><span class="keyword">for</span> fold, (train_ids,valid_ids) <span class="keyword">in</span> <span class="built_in">enumerate</span>(kfold.split(train_val_dataset)):</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;FOLD <span class="subst">&#123;fold&#125;</span>&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;--------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#采样加入噪音</span></span><br><span class="line">  train_subsampler = torch.utils.data.SubsetRandomSampler(train_ids)</span><br><span class="line">  valid_subsampler = torch.utils.data.SubsetRandomSampler(valid_ids)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#因为分割后返回的只是数据集的索引编号，所以需腰引入dataloader</span></span><br><span class="line">  trainloader = torch.utils.data.DataLoader(</span><br><span class="line">                      CutMix(TrainValidData(train_val_path, img_path, transform = train_transform), num_class=<span class="number">176</span>, beta=<span class="number">1.0</span>, prob=<span class="number">0.5</span>, num_mix=<span class="number">2</span>), </span><br><span class="line">                      batch_size=<span class="number">32</span>, sampler=train_subsampler, num_workers=<span class="number">0</span>)</span><br><span class="line">  validloader = torch.utils.data.DataLoader(</span><br><span class="line">                      TrainValidData(train_val_path, img_path, transform = val_test_transform),</span><br><span class="line">                      batch_size=<span class="number">32</span>, sampler=valid_subsampler, num_workers=<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#放到gpu</span></span><br><span class="line">  model = resnest_model(<span class="number">176</span>)</span><br><span class="line">  model = model.to(device)</span><br><span class="line">  model.device = device</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#优化器和优化方案</span></span><br><span class="line">  optimizer = torch.optim.AdamW(model.parameters(),lr=learning_rate,weight_decay= weight_decay)</span><br><span class="line">  scheduler = CosineAnnealingLR(optimizer,T_max=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#训练循环</span></span><br><span class="line">  <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,num_epochs):</span><br><span class="line">    </span><br><span class="line">    model.train()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Starting epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    train_losses = []</span><br><span class="line">    train_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(trainloader):</span><br><span class="line">  <span class="comment">#GPU</span></span><br><span class="line">      imgs, labels = batch</span><br><span class="line">      imgs = imgs.to(device)</span><br><span class="line">      labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">      logits = model(imgs)</span><br><span class="line">      loss = train_loss_function(logits,labels)</span><br><span class="line">      optimizer.zero_grad()</span><br><span class="line">      loss.backward()</span><br><span class="line">      optimizer.step()</span><br><span class="line">    </span><br><span class="line">      <span class="comment"># Compute the accuracy for current batch. 注意这里是每个batch的loss</span></span><br><span class="line">      <span class="comment"># acc = (logits.argmax(dim=-1) == labels).float().mean()</span></span><br><span class="line">      <span class="comment"># Record the loss and accuracy.</span></span><br><span class="line">        </span><br><span class="line">      train_losses.append(loss.item())</span><br><span class="line">      <span class="comment"># train_accs.append(acc)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个epoch的学习率：%f&quot;</span> % (epoch+<span class="number">1</span>,optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    scheduler.step()</span><br><span class="line"><span class="comment"># 总loss / batch数</span></span><br><span class="line">    train_loss = np.<span class="built_in">sum</span>(train_losses) / <span class="built_in">len</span>(train_losses)</span><br><span class="line">    <span class="comment"># train_acc = np.sum(train_accs) / len(train_accs)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;num_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Train process (all epochs) is complete</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Training process has finished. Saving trained model.&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Starting validation&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="validation"><a href="#validation" class="headerlink" title="validation"></a>validation</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这一段代码跟上面是连着的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 按K折存储模型</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;saving model with loss &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(train_loss))</span><br><span class="line">  save_path = <span class="string">f&#x27;./model-fold-<span class="subst">&#123;fold&#125;</span>.pth&#x27;</span></span><br><span class="line">  torch.save(model.state_dict(),save_path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#开始验证</span></span><br><span class="line">  model.<span class="built_in">eval</span>()</span><br><span class="line">  valid_losses = []</span><br><span class="line">  valid_accs = []</span><br><span class="line">  <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(validloader):</span><br><span class="line">      imgs, labels = batch</span><br><span class="line">      logits = model(imgs.to(device))</span><br><span class="line">      <span class="comment">#这里的loss-function用的是nn.CrossEntropyLoss()</span></span><br><span class="line">      loss = valid_loss_function(logits,labels.to(device)) </span><br><span class="line">      acc = (logits.argmax(dim=-<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line">      valid_losses.append(loss.item())        </span><br><span class="line">      valid_accs.append(acc)</span><br><span class="line"></span><br><span class="line">    valid_loss = np.<span class="built_in">sum</span>(valid_losses)/<span class="built_in">len</span>(valid_losses)</span><br><span class="line">    valid_acc = np.<span class="built_in">sum</span>(valid_accs)/<span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;num_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, </span></span><br><span class="line"><span class="string">          acc =<span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accuracy for fold %d: %d&#x27;</span> % (fold, valid_acc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------------------------------&#x27;</span>)</span><br><span class="line">    results[fold] = valid_acc</span><br><span class="line">          </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;K-FOLD CROSS VALIDATION RESULTS FOR <span class="subst">&#123;k_folds&#125;</span> FOLDS&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------------------------------&#x27;</span>)</span><br><span class="line">total_summation = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> results.items():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;Fold <span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span> &#x27;</span>)</span><br><span class="line">  total_summation += value</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Average: <span class="subst">&#123;total_summation/<span class="built_in">len</span>(results.items())&#125;</span> &#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="test-submission"><a href="#test-submission" class="headerlink" title="test submission"></a>test submission</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入TTA数据增强包 不知道增强了什么</span></span><br><span class="line"><span class="keyword">import</span> ttach <span class="keyword">as</span> tta</span><br><span class="line"></span><br><span class="line"><span class="comment">#载入测试数据集</span></span><br><span class="line">testloader = torch.utils.data.DataLoader(</span><br><span class="line">                      TestData(test_path, img_path, transform = val_test_transform),</span><br><span class="line">                      batch_size=<span class="number">32</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##模型预设</span></span><br><span class="line">model = resnest_model(<span class="number">176</span>)</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按K折载入模型</span></span><br><span class="line"><span class="keyword">for</span> test_fold <span class="keyword">in</span> <span class="built_in">range</span>(k_folds):</span><br><span class="line">  model_path = <span class="string">f&#x27;./model-fold-<span class="subst">&#123;test_fold&#125;</span>.pth&#x27;</span></span><br><span class="line">  saveFileName = <span class="string">f&#x27;./submission-fold-<span class="subst">&#123;test_fold&#125;</span>.csv&#x27;</span></span><br><span class="line">  model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">  model.<span class="built_in">eval</span>()</span><br><span class="line">  <span class="comment"># Test-Time Augmentation</span></span><br><span class="line">  tta_model = tta.ClassificationTTAWrapper(model, tta.aliases.five_crop_transform(<span class="number">200</span>,<span class="number">200</span>)) </span><br><span class="line"></span><br><span class="line">  predictions = []</span><br><span class="line">  <span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line">  <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(testloader):</span><br><span class="line">      </span><br><span class="line">      imgs = batch</span><br><span class="line">      <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">          logits = tta_model(imgs.to(device))</span><br><span class="line">      </span><br><span class="line">      predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">  preds = []</span><br><span class="line">  <span class="comment">#将序号转换成对应的叶子名称</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">      preds.append(num_to_class[i])</span><br><span class="line"></span><br><span class="line">  <span class="comment">#存储预测结果</span></span><br><span class="line">  test_data = pd.read_csv(test_path)</span><br><span class="line">  test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">  submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">  submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;ResNeSt Model Results Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="class-dataset"><a href="#class-dataset" class="headerlink" title="class dataset()"></a>class dataset()</h4><p>train&amp;valid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继承pytorch的dataset，创建自己的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrainValidData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, file_path, resize_height=<span class="number">224</span>, resize_width=<span class="number">224</span>, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            csv_path (string): csv 文件路径</span></span><br><span class="line"><span class="string">            img_path (string): 图像文件所在路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 需要调整后的照片尺寸，我这里每张图片的大小尺寸不一致#</span></span><br><span class="line">        self.resize_height = resize_height</span><br><span class="line">        self.resize_width = resize_width</span><br><span class="line"></span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.to_tensor = transforms.ToTensor() <span class="comment">#将数据转换成tensor形式</span></span><br><span class="line">        self.transform = transform</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取 csv 文件</span></span><br><span class="line">        <span class="comment"># 利用pandas读取csv文件</span></span><br><span class="line">        self.data_info = pd.read_csv(csv_path, header=<span class="literal">None</span>)  <span class="comment">#header=None是去掉表头部分</span></span><br><span class="line">        <span class="comment"># 文件第一列包含图像文件名称</span></span><br><span class="line">        self.image_arr = np.asarray(self.data_info.iloc[<span class="number">1</span>:,<span class="number">0</span>]) <span class="comment">#self.data_info.iloc[1:,0]表示读取第一列，从第二行开始一直读取到最后一行</span></span><br><span class="line">        <span class="comment"># 第二列是图像的 label</span></span><br><span class="line">        self.label_arr = np.asarray(self.data_info.iloc[<span class="number">1</span>:,<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 计算 length</span></span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info.index) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># 从 image_arr中得到索引对应的文件名</span></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取图像文件</span></span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(self.file_path + single_image_name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#如果需要将RGB三通道的图片转换成灰度图片可参考下面两行</span></span><br><span class="line">        <span class="comment"># if img_as_img.mode != &#x27;L&#x27;:</span></span><br><span class="line">        <span class="comment">#     img_as_img = img_as_img.convert(&#x27;L&#x27;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#设置好需要转换的变量，还可以包括一系列的nomarlize等等操作</span></span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">            transforms.ToTensor()</span><br><span class="line">        ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到图像的 label</span></span><br><span class="line">        label = self.label_arr[index]</span><br><span class="line">        number_label = class_to_num[label]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (img_as_img, number_label)  <span class="comment">#返回每一个index对应的图片数据和对应的label</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_len</span><br></pre></td></tr></table></figure><p>test</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继承pytorch的dataset，创建自己的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, file_path, resize_height=<span class="number">224</span>, resize_width=<span class="number">224</span>, transform = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            csv_path (string): csv 文件路径</span></span><br><span class="line"><span class="string">            img_path (string): 图像文件所在路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 需要调整后的照片尺寸，我这里每张图片的大小尺寸不一致#</span></span><br><span class="line">        self.resize_height = resize_height</span><br><span class="line">        self.resize_width = resize_width</span><br><span class="line"></span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.to_tensor = transforms.ToTensor() <span class="comment">#将数据转换成tensor形式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取 csv 文件</span></span><br><span class="line">        <span class="comment"># 利用pandas读取csv文件</span></span><br><span class="line">        self.data_info = pd.read_csv(csv_path, header=<span class="literal">None</span>)  <span class="comment">#header=None是去掉表头部分</span></span><br><span class="line">        <span class="comment"># 文件第一列包含图像文件名称</span></span><br><span class="line">        self.image_arr = np.asarray(self.data_info.iloc[<span class="number">1</span>:,<span class="number">0</span>]) <span class="comment">#self.data_info.iloc[1:,0]表示读取第一列，从第二行开始一直读取到最后一行</span></span><br><span class="line">        <span class="comment"># 计算 length</span></span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info.index) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># 从 image_arr中得到索引对应的文件名</span></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取图像文件</span></span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(self.file_path + single_image_name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#如果需要将RGB三通道的图片转换成灰度图片可参考下面两行</span></span><br><span class="line">        <span class="comment"># if img_as_img.mode != &#x27;L&#x27;:</span></span><br><span class="line">        <span class="comment">#     img_as_img = img_as_img.convert(&#x27;L&#x27;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#设置好需要转换的变量，还可以包括一系列的nomarlize等等操作</span></span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">            transforms.ToTensor()</span><br><span class="line">        ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img_as_img</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_len</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/19/hello-world/"/>
      <url>/2022/11/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
