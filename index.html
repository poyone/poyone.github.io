<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Attention Is A Talent</title><meta name="author" content="Poy One"><meta name="copyright" content="Poy One"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Attention Is A Talent">
<meta property="og:url" content="https://poyone.github.io/index.html">
<meta property="og:site_name" content="Attention Is A Talent">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/poyone1222/eris/eris11.webp">
<meta property="article:author" content="Poy One">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/poyone1222/eris/eris11.webp"><link rel="shortcut icon" href="https://npm.elemecdn.com/poyone1222/eris/eris11.webp"><link rel="canonical" href="https://poyone.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Attention Is A Talent',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-15 22:44:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/eris11.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Attention Is A Talent</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Attention Is A Talent</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/poyone" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:poyone1222@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/posts/28501.html" title="Scrapy 01 tutorial"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/Bocchi the Rock/bocchi9.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Scrapy 01 tutorial"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/28501.html" title="Scrapy 01 tutorial">Scrapy 01 tutorial</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-15T03:33:39.993Z" title="发表于 2022-12-15 11:33:39">2022-12-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-15T13:40:50.889Z" title="更新于 2022-12-15 21:40:50">2022-12-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Universe/">Universe</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Scrapy/">Scrapy</a></span></div><div class="content">
如果vscode中你的终端不能识别scrapy可以在环境变量中加入scrapy.exe的路径

启动安装好后，在目标文件夹内启动scrapy startproject tutorial命令，将会创建如下文件
12345678910111213141516tutorial/    scrapy.cfg            # deploy configuration file    tutorial/             # project&#x27;s Python module, you&#x27;ll import your code from here        __init__.py        items.py          # project items definition file        middlewares.py    # project middlewares file        pipelines.py      # project pipelines file        settings.py       # project settings file        spiders/          # a directory where you&#x27;ll later put your spiders            __init__.py





在tutorial/spiders目录下创建我们的第一个爬虫命名为quotes_spider.py
1234567891011121314151617181920import scrapyclass QuotesSpider(scrapy.Spider):    name = &quot;quotes&quot;    def start_requests(self):        urls = [            &#x27;https://quotes.toscrape.com/page/1/&#x27;,            &#x27;https://quotes.toscrape.com/page/2/&#x27;,        ]        for url in urls:            yield scrapy.Request(url=url, callback=self.parse)    def parse(self, response):        page = response.url.split(&quot;/&quot;)[-2]        filename = f&#x27;quotes-&#123;page&#125;.html&#x27;        with open(filename, &#x27;wb&#x27;) as f:            f.write(response.body)        self.log(f&#x27;Saved file &#123;filename&#125;&#x27;)



终端中启动爬虫scrapy crawl quotes会得到两个文件quotes-1.html and quotes-2.html
scrapy shell在解析他两之前，我们介绍 Scrapy shell，用来调试我们输出 scrapy shell &lt;url&gt;

pip install ipython之后 在上级目录中找到scrapy.cfg文件在setting下加入
shell = bpython 如果你的ipython不能用的话
输入exit可以退出

1234567891011121314151617scrapy shell &quot;https://quotes.toscrape.com/page/1/&quot;&#x27;&#x27;&#x27;[ ... Scrapy log here ... ]2016-09-19 12:09:27 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://quotes.toscrape.com/page/1/&gt; (referer: None)[s] Available Scrapy objects:[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x7fa91d888c90&gt;[s]   item       &#123;&#125;[s]   request    &lt;GET https://quotes.toscrape.com/page/1/&gt;[s]   response   &lt;200 https://quotes.toscrape.com/page/1/&gt;[s]   settings   &lt;scrapy.settings.Settings object at 0x7fa91d888c10&gt;[s]   spider     &lt;DefaultSpider &#x27;default&#x27; at 0x7fa91c8af990&gt;[s] Useful shortcuts:[s]   shelp()           Shell help (print this help)[s]   fetch(req_or_url) Fetch request (or URL) and update local objects[s]   view(response)    View response in a browser&#x27;&#x27;&#x27;

以上是返回的一些可以操作的对象
12response.css(&#x27;title&#x27;)# [&lt;Selector xpath=&#x27;descendant-or-self::title&#x27; data=&#x27;&lt;title&gt;Quotes to Scrape&lt;/title&gt;&#x27;&gt;]

如此可以实现交互式运行
css语法::text12response.css(&#x27;title::text&#x27;).getall()# [&#x27;Quotes to Scrape&#x27;]

12response.css(&#x27;title&#x27;).getall()# [&#x27;&lt;title&gt;Quotes to Scrape&lt;/title&gt;&#x27;]

get&#x2F;getall返回一个，或者全部
正则123456response.css(&#x27;title::text&#x27;).re(r&#x27;Quotes.*&#x27;)# [&#x27;Quotes to Scrape&#x27;]response.css(&#x27;title::text&#x27;).re(r&#x27;Q\w+&#x27;)# [&#x27;Quotes&#x27;]response.css(&#x27;title::text&#x27;).re(r&#x27;(\w+) to (\w+)&#x27;)# [&#x27;Quotes&#x27;, &#x27;Scrape&#x27;]



Xpath官方推荐使用这个，但我觉得css写的更方便一点
1234response.xpath(&#x27;//title&#x27;)# [&lt;Selector xpath=&#x27;//title&#x27; data=&#x27;&lt;title&gt;Quotes to Scrape&lt;/title&gt;&#x27;&gt;]response.xpath(&#x27;//title/text()&#x27;).get()# &#x27;Quotes to Scrape&#x27;



提取数据12345678910111213141516&#x27;&#x27;&#x27;&lt;div class=&quot;quote&quot;&gt;    &lt;span class=&quot;text&quot;&gt;“The world as we have created it is a process of our    thinking. It cannot be changed without changing our thinking.”&lt;/span&gt;    &lt;span&gt;        by &lt;small class=&quot;author&quot;&gt;Albert Einstein&lt;/small&gt;        &lt;a href=&quot;/author/Albert-Einstein&quot;&gt;(about)&lt;/a&gt;    &lt;/span&gt;    &lt;div class=&quot;tags&quot;&gt;        Tags:        &lt;a class=&quot;tag&quot; href=&quot;/tag/change/page/1/&quot;&gt;change&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/deep-thoughts/page/1/&quot;&gt;deep-thoughts&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/thinking/page/1/&quot;&gt;thinking&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/world/page/1/&quot;&gt;world&lt;/a&gt;    &lt;/div&gt;&lt;/div&gt;&#x27;&#x27;&#x27;

scrapy shell &#39;https://quotes.toscrape.com&#39;
单个提取12345response.css(&quot;div.quote&quot;)&#x27;&#x27;&#x27;[&lt;Selector xpath=&quot;descendant-or-self::div[@class and contains(concat(&#x27; &#x27;, normalize-space(@class), &#x27; &#x27;), &#x27; quote &#x27;)]&quot; data=&#x27;&lt;div class=&quot;quote&quot; itemscope itemtype...&#x27;&gt;, &lt;Selector xpath=&quot;descendant-or-self::div[@class and contains(concat(&#x27; &#x27;, normalize-space(@class), &#x27; &#x27;), &#x27; quote &#x27;)]&quot; data=&#x27;&lt;div class=&quot;quote&quot; itemscope itemtype...&#x27;&gt;, ...]&#x27;&#x27;&#x27;


分为两个部分selector和data ，data就是我们操作的分布

12345678910quote = response.css(&quot;div.quote&quot;)[0]text = quote.css(&quot;span.text::text&quot;).get()text&#x27;&#x27;&#x27;&#x27;“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”&#x27; &#x27;&#x27;&#x27;author = quote.css(&quot;small.author::text&quot;).get()author# &#x27;Albert Einstein&#x27;


response.css搜寻的格式为’标签.标签名称’
quote为我们html文件中所有class&#x3D;quote的标签组，
组内span.text标签下为名言、组内small.author为作者

小组提取12345678910111213141516&#x27;&#x27;&#x27;&lt;div class=&quot;quote&quot;&gt;    &lt;span class=&quot;text&quot;&gt;“The world as we have created it is a process of our    thinking. It cannot be changed without changing our thinking.”&lt;/span&gt;    &lt;span&gt;        by &lt;small class=&quot;author&quot;&gt;Albert Einstein&lt;/small&gt;        &lt;a href=&quot;/author/Albert-Einstein&quot;&gt;(about)&lt;/a&gt;    &lt;/span&gt;    &lt;div class=&quot;tags&quot;&gt;        Tags:        &lt;a class=&quot;tag&quot; href=&quot;/tag/change/page/1/&quot;&gt;change&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/deep-thoughts/page/1/&quot;&gt;deep-thoughts&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/thinking/page/1/&quot;&gt;thinking&lt;/a&gt;        &lt;a class=&quot;tag&quot; href=&quot;/tag/world/page/1/&quot;&gt;world&lt;/a&gt;    &lt;/div&gt;&lt;/div&gt;&#x27;&#x27;&#x27;



123tags = quote.css(&quot;div.tags a.tag::text&quot;).getall()tags# [&#x27;change&#x27;, &#x27;deep-thoughts&#x27;, &#x27;thinking&#x27;, &#x27;world&#x27;]



全部提取12345678for quote in response.css(&quot;div.quote&quot;):    text = quote.css(&quot;span.text::text&quot;).get()    author = quote.css(&quot;small.author::text&quot;).get()    tags = quote.css(&quot;div.tags a.tag::text&quot;).getall()    print(dict(text=text, author=author, tags=tags))&#x27;&#x27;&#x27;&#123;&#x27;text&#x27;: &#x27;“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”&#x27;, &#x27;author&#x27;: &#x27;Albert Einstein&#x27;, &#x27;tags&#x27;: [&#x27;change&#x27;, &#x27;deep-thoughts&#x27;, &#x27;thinking&#x27;, &#x27;world&#x27;]&#125;&#123;&#x27;text&#x27;: &#x27;“It is our choices, Harry, that show what we truly are, far more than our abilities.”&#x27;, &#x27;author&#x27;: &#x27;J.K. Rowling&#x27;, &#x27;tags&#x27;: [&#x27;abilities&#x27;, &#x27;choices&#x27;]&#125;&#x27;&#x27;&#x27;



数据保存scrapy crawl spiderman -O spn.json
1234567891011121314151617import scrapyclass QuotesSpider(scrapy.Spider):    name = &quot;quotes&quot;    start_urls = [        &#x27;https://quotes.toscrape.com/page/1/&#x27;,        &#x27;https://quotes.toscrape.com/page/2/&#x27;,    ]    def parse(self, response):        for quote in response.css(&#x27;div.quote&#x27;):            yield &#123;                &#x27;text&#x27;: quote.css(&#x27;span.text::text&#x27;).get(),                &#x27;author&#x27;: quote.css(&#x27;small.author::text&#x27;).get(),                &#x27;tags&#x27;: quote.css(&#x27;div.tags a.tag::text&#x27;).getall(),            &#125;



启动爬虫会获得如下内容:
注要在爬虫的根目录启动爬虫
12345&#x27;&#x27;&#x27;2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://quotes.toscrape.com/page/1/&gt;&#123;&#x27;tags&#x27;: [&#x27;life&#x27;, &#x27;love&#x27;], &#x27;author&#x27;: &#x27;André Gide&#x27;, &#x27;text&#x27;: &#x27;“It is better to be hated for what you are than to be loved for what you are not.”&#x27;&#125;2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://quotes.toscrape.com/page/1/&gt;&#123;&#x27;tags&#x27;: [&#x27;edison&#x27;, &#x27;failure&#x27;, &#x27;inspirational&#x27;, &#x27;paraphrased&#x27;], &#x27;author&#x27;: &#x27;Thomas A. Edison&#x27;, &#x27;text&#x27;: &quot;“I have not failed. I&#x27;ve just found 10,000 ways that won&#x27;t work.”&quot;&#125;&#x27;&#x27;&#x27;



输出格式scrapy crawl quotes -O quotes.json

-O将会覆写同名文件已存在的内容，
-o则会在已存在文件的后面增加内容，但是新旧格式可能不同，可以使用
scrapy crawl quotes -o quotes.jsonl

有json、jsonl、csv、xml四种格式
爬取整个网站123456&#x27;&#x27;&#x27;&lt;ul class=&quot;pager&quot;&gt;    &lt;li class=&quot;next&quot;&gt;        &lt;a href=&quot;/page/2/&quot;&gt;Next &lt;span aria-hidden=&quot;true&quot;&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;&#x27;&#x27;&#x27;



12response.css(&#x27;li.next a&#x27;).get()# &#x27;&lt;a href=&quot;/page/2/&quot;&gt;Next &lt;span aria-hidden=&quot;true&quot;&gt;→& ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/55870.html" title="diffusion 综述"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/Eris37.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="diffusion 综述"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/55870.html" title="diffusion 综述">diffusion 综述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-13T14:06:13.619Z" title="发表于 2022-12-13 22:06:13">2022-12-13</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-15T13:01:04.564Z" title="更新于 2022-12-15 21:01:04">2022-12-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Dive-Into-Paper/">Dive Into Paper</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/diffusion/">diffusion</a></span></div><div class="content">待排版
第一部分是DDPM时代的图像编辑。因为还没有任何的引导生成技术的出现，这一阶段的论文都属于利用输入图像引导生成的范式。
第二部分是在显式分类器引导生成技术出现后，基于CLIP模型的多模态引导生成技术的调研。
第三部分是最近（2022.11）一两个月基于Stable-Diffusion&#x2F;Imagen等一系列模型所产生的图像编辑技术的调研。

不像人话
第一阶段: DDPM
加噪 diffusion 再降噪还原 全局修改
逐步发现对梯度的控制很重要，于是加入对梯度控制。DDPM-&gt;IVLR-&gt;SDEdit-&gt;RePaint
最后从打补丁控制生成的基础上，引导出了对导数的控制
第二阶段: DDIM 
Diffusion Models Beat GANs on Image Synthesis 加入10倍的定向梯度控制 
More Control for Free! Image Synthesis with Semantic Diffusion Guidance : CLIP 可以局部修改
想要使用一个文本来引导图像生成，我们可以每一步都计算现在的图像表征和文本表征的距离，使用方程的梯度来计算缩小这个距离的方向
但就在十天之后OpenAI发布了GLIDE，使用了下面会提到的隐式分类器引导的图像生成
随着新的更强大更便捷的模型如Stable-Diffusion, Imagen等如雨后春笋般涌现，上面的各项工作可能只剩下了借鉴意义。
Classifier-Free Diffusion Guidance :基于隐式分类器的文生图大模型
无分类器引导可以说是GLIDE&#x2F;Stable-Diffusion&#x2F;Imagen的做法的直接奠基工作之一
第三阶段: 
在隐式分类器上引导生成过程中的调控生成

第一种是根据扩散模型迭代去噪的特性，我们在模型的低频细节上继续生成。这种做法虽然能保留大部分几何特征，但是也同样无法调控几何特征。

Imagic: Text-Based Real Image Editing with Diffusion Models:
具体来说，Imagic将概念绑定这件事拆成了三个步骤，对于输入图像x和我们希望生成的目标描述文本text_target来说：
1：我们首先冻结整个模型，使用模型训练时的生成目标来微调text_target的文本表征，使其接近于图像的表征。
2：我们放开整个模型的权重更新，依然使用训练时的生成目标，但这次全模型微调。模型的输入是图像x和我们微调后的文本表征。这一步是因为哪怕我们让目标文本表征和原图的表征接近了，也不能保证我们输入让我们微调后的目标文本表征可以生成我们的原图，所以我们再次将这两个概念一起训练，使得我们可以使用微调后的目标文本表征生成我们的原图
3：既然我们已经将原图和微调后的新文本表征绑定起来了，现在我们再使用原本的目标文本表征与微调后的文本表征做插值，来对原图像施加影响即可。

训练好图形输出锁住参数-&gt; 微调全参数适应文本输出-&gt; 开放全参数两个一起训练 -&gt;将两个概念捆绑并开放修改
简单来讲可以将微调后的目标文本表征近似当作原图像原生的文本表征，那么最后一步使用目标表征对原生的表征施加影响就非常自然了

DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation
具体来说作者提出了使用稀缺词加种类词如“beikkpic dog”的组合文本来微调一组照片和这个文本的绑定。但是仅仅用少量的照片来微调一个有着大量参数的模型很明显会带来极为严重的过拟合。并且还会带来一个语言模型里特别常见的事情–灾难性遗忘。这两个问题的表现一个是绑定词的形态很难变换，就如上篇的Unitune一样。另一个问题是对种类词里面的种类生成也会快速失去多样性和变化性。于是针对这个问题作者针对性地提出了一个叫自身类别先验保存损失的损失函数。
这个函数的设计是在用户提供一个指定的类别和这个类别的一组图片（如自家的宠物狗的多张照片）后，模型同时使用“特殊词+类别”对用户照片训练和“类别”与模型生成的该类别图训练。这样做的好处是模型可以在将特定的照片主体与特殊词绑定的时候可以一起学到和其类别的关系，并且同时该类别的信息在不断的被重申以对抗用户照片信息的冲击。作者在训练的时候特意将这两个损失以一比一的比例训练了200个轮次左右。(单卡GPU 15分钟左右就可以)
Prompt-to-Prompt Image Editing with Cross-Attention Control
这篇文章的洞见来自于一个重要思考：即多模态里文生图的文本是如何对生成过程施加影响的？

基于隐式分类器的文图模型是通过训练一个既可以做无条件生成的梯度预估，也可以做条件生成的梯度预估的模型实现的。而其中这个条件交互的方式在Imagen和Stable-Diffusion里都是通过cross-attention实现信息融合的。那么很明显，我们的着眼点也应该在cross-attention上。

而作者的洞见则在于：我们输入的文本和像素之间存在着一个空间对应的关系。通过调控注意力和像素间的映射。我们能够对图像的不同区域实施准确的引导。
![](..&#x2F;..&#x2F;article_img&#x2F;paper_img&#x2F;diffusion&#x2F;bear attn.png)
有了以上洞见据此进行图像引导生成就很直观了，作者将其分为三个主要场景：单词替换（比如在上图里将熊换成猫则将猫这个token对应的map换成熊的map），单词增添（在原有的map上增加新的单词的map），注意力重加权（如果想放大或减弱某个词对原图的引导效果则对其map乘上新的权重值，如降低下雪的效果开花的程度等）
原链
</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/7194.html" title="HF Course 09 Custom Tokenizer"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/Eris11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HF Course 09 Custom Tokenizer"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7194.html" title="HF Course 09 Custom Tokenizer">HF Course 09 Custom Tokenizer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-12T08:15:06.518Z" title="发表于 2022-12-12 16:15:06">2022-12-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T14:31:52.517Z" title="更新于 2022-12-12 22:31:52">2022-12-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Universe/">Universe</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Huggingface/">Huggingface</a></span></div><div class="content">
与之前继承式的分词器不同，这词我们将从语料库中训练一个全新的分词器
首先我们设置一个WordPiece类型的分词器

加载文档12345678910111213from datasets import load_datasetdataset = load_dataset(&quot;wikitext&quot;, name=&quot;wikitext-2-raw-v1&quot;, split=&quot;train&quot;)def get_training_corpus():    for i in range(0, len(dataset), 1000):        yield dataset[i : i + 1000][&quot;text&quot;]# 也可以从本地打开文档with open(&quot;wikitext-2.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:    for i in range(len(dataset)):        f.write(dataset[i][&quot;text&quot;] + &quot;\n&quot;)



加载构件1234567891011from tokenizers import (    decoders,    models,    normalizers,    pre_tokenizers,    processors,    trainers,    Tokenizer,)tokenizer = Tokenizer(models.WordPiece(unk_token=&quot;[UNK]&quot;))

我们从tokenizer库中加载特殊的model构件，来使用WordPiece方法
设定遇到没见过的词标记为[UNK]， 同时可以设置max_input_chars_per_word作为最大词长
设置Normalizer这里我们选择bert的设置，包括: 
所有字母小写、strip_accents除去重音、删除控制字符、将所有多个空格设置为单个空格、汉字周围放置空格。
123456789tokenizer.normalizer = normalizers.BertNormalizer(lowercase=True)# 你也可以自定义tokenizer.normalizer = normalizers.Sequence(    [normalizers.NFD(), normalizers.Lowercase(), normalizers.StripAccents()])print(tokenizer.normalizer.normalize_str(&quot;Héllò hôw are ü?&quot;))# hello how are u?

上面自定义中我们使用Sequence方法定义我们自己的规范化规则
Pre-tokenization和上面一样可以通过tokenizer.pre_tokenizer = pre_tokenizers.BertPreTokenizer()套用bert的设置
下面是custom版本
12345tokenizer.pre_tokenizer = pre_tokenizers.Whitespace()tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Let&#x27;s test my pre-tokenizer.&quot;)&#x27;&#x27;&#x27;[(&#x27;Let&#x27;, (0, 3)), (&quot;&#x27;&quot;, (3, 4)), (&#x27;s&#x27;, (4, 5)), (&#x27;test&#x27;, (6, 10)), (&#x27;my&#x27;, (11, 13)), (&#x27;pre&#x27;, (14, 17)), (&#x27;-&#x27;, (17, 18)), (&#x27;tokenizer&#x27;, (18, 27)), (&#x27;.&#x27;, (27, 28))]&#x27;&#x27;&#x27;



.Whitespace()是对标点空格分隔，你可用下面的分隔
1234pre_tokenizer = pre_tokenizers.WhitespaceSplit()pre_tokenizer.pre_tokenize_str(&quot;Let&#x27;s test my pre-tokenizer.&quot;)&#x27;&#x27;&#x27;[(&quot;Let&#x27;s&quot;, (0, 5)), (&#x27;test&#x27;, (6, 10)), (&#x27;my&#x27;, (11, 13)), (&#x27;pre-tokenizer.&#x27;, (14, 28))]&#x27;&#x27;&#x27;



推荐使用Sequence方法组合你的预分词
1234567pre_tokenizer = pre_tokenizers.Sequence(    [pre_tokenizers.WhitespaceSplit(), pre_tokenizers.Punctuation()])pre_tokenizer.pre_tokenize_str(&quot;Let&#x27;s test my pre-tokenizer.&quot;)&#x27;&#x27;&#x27;[(&#x27;Let&#x27;, (0, 3)), (&quot;&#x27;&quot;, (3, 4)), (&#x27;s&#x27;, (4, 5)), (&#x27;test&#x27;, (6, 10)), (&#x27;my&#x27;, (11, 13)), (&#x27;pre&#x27;, (14, 17)), (&#x27;-&#x27;, (17, 18)), (&#x27;tokenizer&#x27;, (18, 27)), (&#x27;.&#x27;, (27, 28))]&#x27;&#x27;&#x27;



Trainer训练之前我们需要加入特殊token因为他不在你的词库之中
12special_tokens = [&quot;[UNK]&quot;, &quot;[PAD]&quot;, &quot;[CLS]&quot;, &quot;[SEP]&quot;, &quot;[MASK]&quot;]trainer = trainers.WordPieceTrainer(vocab_size=25000, special_tokens=special_tokens)


As well as specifying the vocab_size and special_tokens, we can set the min_frequency (the number of times a token must appear to be included in the vocabulary) or change the continuing_subword_prefix (if we want to use something different from ##).
改某个token必须出现多少次、改连接前缀##为别的



开始训练
12345tokenizer.train_from_iterator(get_training_corpus(), trainer=trainer)# 另外的版本tokenizer.model = models.WordPiece(unk_token=&quot;[UNK]&quot;)tokenizer.train([&quot;wikitext-2.txt&quot;], trainer=trainer)

第一种方法是用上面定义的生成器
第二种传入”wikitext-2.txt”文件
到此我们tokenizer就具有了一般tokenizer的所有方法如encode
1234encoding = tokenizer.encode(&quot;Let&#x27;s test this tokenizer.&quot;)print(encoding.tokens)# [&#x27;let&#x27;, &quot;&#x27;&quot;, &#x27;s&#x27;, &#x27;test&#x27;, &#x27;this&#x27;, &#x27;tok&#x27;, &#x27;##eni&#x27;, &#x27;##zer&#x27;, &#x27;.&#x27;]



Post-processing最后我们需要包裹我们的token到特殊的格式如: [CLS]…[SEP]…[SEP]
首先我们获取所需的特殊token的下标
12345cls_token_id = tokenizer.token_to_id(&quot;[CLS]&quot;)sep_token_id = tokenizer.token_to_id(&quot;[SEP]&quot;)print(cls_token_id, sep_token_id)# (2, 3)



接下来处理我们的模板
12345tokenizer.post_processor = processors.TemplateProcessing(    single=f&quot;[CLS]:0 $A:0 [SEP]:0&quot;,    pair=f&quot;[CLS]:0 $A:0 [SEP]:0 $B:1 [SEP]:1&quot;,    special_tokens=[(&quot;[CLS]&quot;, cls_token_id), (&quot;[SEP]&quot;, sep_token_id)],)

模板我们需要设置两种模式:

single–单个句子情况下

[0,0,0,0]


pair

[0,0,0,1,1,1]


最后指定特殊token的id


查看
12345678910encoding = tokenizer.encode(&quot;Let&#x27;s test this tokenizer.&quot;)print(encoding.tokens)# [&#x27;[CLS]&#x27;, &#x27;let&#x27;, &quot;&#x27;&quot;, &#x27;s&#x27;, &#x27;test&#x27;, &#x27;this&#x27;, &#x27;tok&#x27;, &#x27;##eni&#x27;, &#x27;##zer&#x27;, &#x27;.&#x27;, &#x27;[SEP]&#x27;]encoding = tokenizer.encode(&quot;Let&#x27;s test this tokenizer...&quot;, &quot;on a pair of sentences.&quot;)print(encoding.tokens)print(encoding.type_ids)&#x27;&#x27;&#x27;[&#x27;[CLS]&#x27;, &#x27;let&#x27;, &quot;&#x27;&quot;, &#x27;s&#x27;, &#x27;test&#x27;, &#x27;this&#x27;, &#x27;tok&#x27;, &#x27;##eni&#x27;, &#x27;##zer&#x27;, &#x27;...&#x27;, &#x27;[SEP]&#x27;, &#x27;on&#x27;, &#x27;a&#x27;, &#x27;pair&#x27;, &#x27;of&#x27;, &#x27;sentences&#x27;, &#x27;.&#x27;, &#x27;[SEP]&#x27;][0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]&#x27;&#x27;&#x27;



decoder接下来对解码器做一定设置
1234tokenizer.decoder = decoders.WordPiece(prefix=&quot;##&quot;)tokenizer.decode(encoding.ids)# &quot;let&#x27;s test this tokenizer... on a pair of sentences.&quot;



保存 &amp; 加载 Custom Tokenizertokenizer.save(&quot;tokenizer.json&quot;)
new_tokenizer = Tokenizer.from_file(&quot;tokenizer.json&quot;)
转成Fast TokenizerTo use this tokenizer in 🤗 Transformers, we have to wrap it in a PreTrainedTokenizerFast. We can either use the generic class or, if our tokenizer corresponds to an existing model, use that class (here, BertTokenizerFast). If you apply this lesson to build a brand new tokenizer, you will have to use the first option.

可以继承你的特定类BertTokenizerFast，也可以用泛类PreTrainedTokenizerFast

1234567891011from transformers import PreTrainedTokenizerFastwrapped_tokenizer = PreTrainedTokenizerFast(    tokenizer_object=tokenizer,    # tokenizer_file=&quot;tokenizer.json&quot;, # You can load from the tokenizer file, alternatively    unk_token=&quot;[UNK]&quot;,    pad_token=&quot;[PAD]&quot;,    cls_token=&quot;[CLS]&quot;,    sep_token=&quot;[SEP]&quot;,    mask_token=&quot;[MASK]&quot;,)

这里可以从文件中加载你的tokenizer设置、也可直接赋值、注意你的特殊符号必须重新定义
BPE类型的分词器1234567tokenizer = Tokenizer(models.BPE())tokenizer.pre_tokenizer = pre_tokenizers.ByteLevel(add_prefix_space=False)tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Let&#x27;s test pre-tokenization!&quot;)&#x27;&#x27;&#x27;[(&#x27;Let&#x27;, (0, 3)), (&quot;&#x27;s&quot;, (3, 5)), (&#x27;Ġtest&#x27;, (5, 10)), (&#x27;Ġpre&#x27;, (10, 14)), (&#x27;-&#x27;, (14, 15)), (&#x27;tokenization&#x27;, (15, 27)), (&#x27;!&#x27;, (27, 28))]&#x27;&#x27;&#x27;



GPT2只需要开始和结束的特殊token
12345678910trainer = trainers.BpeTrainer(vocab_size=25000, special_tokens=[&quot;&lt;|endoftext|&gt;&quot;])tokenizer.train_from_iterator(get_training_corpus(), trainer=trainer)tokenizer.model = models.BPE()tokenizer.train([&quot;wikitext-2.txt&quot;], trainer=trainer)encoding = tokenizer.encode(&quot;Let&#x27;s test this tokenizer.&quot;)print(encoding.tokens)&#x27;&#x27;&#x27;[&#x27;L&#x27;, &#x27;et&#x27;, &quot;&#x27;&quot;, &#x27;s&#x27;, &#x27;Ġtest&#x27;, &#x27;Ġthis&#x27;, &#x27;Ġto&#x27;, &#x27;ken&#x27;, &#x27;izer&#x27;, &#x27;.&#x27;]&#x27;&#x27;&#x27;





12345678tokenizer.post_processor = processors.ByteLevel(trim_offsets=False)sentence = &quot;Let&#x27;s test this tokenizer.&quot;encoding = tokenizer.encode(sentence)start, end = encoding.offsets[4]sentence[start:end]# &#x27; test&#x27;

The trim_offsets = False option indicates to the post-processor that we should leave the offsets of tokens that begin with ‘Ġ’ as they are: this way the start of the offsets will point to the space before the word, not the first character of the word (since the space is technically part of the token). Let’s have a look at the result with the text we just encoded, where &#39;Ġtest&#39; is the token at index 4

trim_offsets设定是否修正字符的空格位置进入偏移量

123tokenizer.decoder = decoders.ByteLevel()tokenizer.decode(encoding.ids)# &quot;Let&#x27;s test this tokenizer.&quot;



包装
123456789101112from transformers import PreTrainedTokenizerFastwrapped_tokenizer = PreTrainedTokenizerFast(    tokenizer_object=tokenizer,    bos_token=&quot;&lt;|endoftext|&gt;&quot;,    eos_token=&quot;&lt;|endoftext|&gt;&quot;,)# 或者from transformers import GPT2TokenizerFastwrapped_tokenizer = GPT2TokenizerFast(tokenizer_object=tokenizer)



Unigram类型的分词器12345678910111213tokenizer = Tokenizer(models.Unigram())from tokenizers import Regextokenizer.normalizer = normalizers.Sequence(    [        normalizers.Replace(&quot;``&quot;, &#x27;&quot;&#x27;),        normalizers.Replace(&quot;&#x27;&#x27;&quot;, &#x27;&quot;&#x27;),        normalizers.NFKD(),        normalizers.StripAccents(),        normalizers.Replace(Regex(&quot; &#123;2,&#125;&quot;), &quot; &quot;),    ])

第一、二个norm将符号替换，最后一个将多个空格替换成一个
1234tokenizer.pre_tokenizer = pre_tokenizers.Metaspace()tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Let&#x27;s test the pre-tokenizer!&quot;)# [(&quot;▁Let&#x27;s&quot;, (0, 5)), (&#x27;▁test&#x27;, (5, 10)), (&#x27;▁the&#x27;, (10, 14)), (&#x27;▁pre-tokenizer!&#x27;, (14, 29))]



123456789special_tokens = [&quot;&lt;cls&gt;&quot;, &quot;&lt;sep&gt;&quot;, &quot;&lt;unk&gt;&quot;, &quot;&lt;pad&gt;&quot;, &quot;&lt;mask&gt;&quot;, &quot;&lt;s&gt;&quot;,  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/7193.html" title="HF Course 08 Tokenizer底层算法"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/Eris11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HF Course 08 Tokenizer底层算法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7193.html" title="HF Course 08 Tokenizer底层算法">HF Course 08 Tokenizer底层算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-12T03:35:18.892Z" title="发表于 2022-12-12 11:35:18">2022-12-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T14:30:42.647Z" title="更新于 2022-12-12 22:30:42">2022-12-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Universe/">Universe</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Huggingface/">Huggingface</a></span></div><div class="content">流程一般来说我们的tokenizer有如下流程

规范化规范化是对字符做大小写处理之类的我们可以通过如下API查看底层的normalization方法
123456789from transformers import AutoTokenizertokenizer = AutoTokenizer.from_pretrained(&quot;bert-base-uncased&quot;)print(type(tokenizer.backend_tokenizer))# &lt;class &#x27;tokenizers.Tokenizer&#x27;&gt;print(tokenizer.backend_tokenizer.normalizer.normalize_str(&quot;Héllò hôw are ü?&quot;))# &#x27;hello how are u?&#x27;



预分词通过如下api查看分词器是如何做pre_tokenize的
123tokenizer.backend_tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Hello, how are  you?&quot;)&#x27;&#x27;&#x27;&#x27;[(&#x27;Hello&#x27;, (0, 5)), (&#x27;,&#x27;, (5, 6)), (&#x27;how&#x27;, (7, 10)), (&#x27;are&#x27;, (11, 14)), (&#x27;you&#x27;, (16, 19)), (&#x27;?&#x27;, (19, 20))]&#x27;&#x27;&#x27;

可以看到后面的偏移量坐标，这也是上一节offset-mapping的由来
不同的预分词gpt
1234tokenizer = AutoTokenizer.from_pretrained(&quot;gpt2&quot;)tokenizer.backend_tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Hello, how are  you?&quot;)&#x27;&#x27;&#x27;[(&#x27;Hello&#x27;, (0, 5)), (&#x27;,&#x27;, (5, 6)), (&#x27;Ġhow&#x27;, (6, 10)), (&#x27;Ġare&#x27;, (10, 14)), (&#x27;Ġ&#x27;, (14, 15)), (&#x27;Ġyou&#x27;, (15, 19)),(&#x27;?&#x27;, (19, 20))]&#x27;&#x27;&#x27;&#x27;



t5
123tokenizer = AutoTokenizer.from_pretrained(&quot;t5-small&quot;)tokenizer.backend_tokenizer.pre_tokenizer.pre_tokenize_str(&quot;Hello, how are  you?&quot;)# [(&#x27;▁Hello,&#x27;, (0, 6)), (&#x27;▁how&#x27;, (7, 10)), (&#x27;▁are&#x27;, (11, 14)), (&#x27;▁you?&#x27;, (16, 20))]



三种分词算法总览如上，不同的模型适用不同的分词算法
sentencepiece它经常与unigram算法一起，且并不需要预分词，是特攻中文日文，这种无法分词的语言的
算法预览


Model
BPE
WordPiece
Unigram



Training
Starts from a small vocabulary and learns rules to merge tokens
Starts from a small vocabulary and learns rules to merge tokens
Starts from a large vocabulary and learns rules to remove tokens


Training step
Merges the tokens corresponding to the most common pair
Merges the tokens corresponding to the pair with the best score based on the frequency of the pair, privileging pairs where each individual token is less frequent
Removes all the tokens in the vocabulary that will minimize the loss computed on the whole corpus


Learns
Merge rules and a vocabulary
Just a vocabulary
A vocabulary with a score for each token


Encoding
Splits a word into characters and applies the merges learned during training
Finds the longest subword starting from the beginning that is in the vocabulary, then does the same for the rest of the word
Finds the most likely split into tokens, using the scores learned during training


BPE简述BPE是Byte-Pair Encoding 的简写，他有三步

将corpus所有独一无二字符拆出来，如英文中的26个字母，标点和其他特殊符号
在有基础字符的基础上，以频率作为选取标准，将两个字符匹配在一起，选择频率最高的词进行入库
重复第二步直到满足你设定的词库大小


The GPT-2 and RoBERTa tokenizers (which are pretty similar) have a clever way to deal with this: they don’t look at words as being written with Unicode characters, but with bytes. This way the base vocabulary has a small size (256), but every character you can think of will still be included and not end up being converted to the unknown token. This trick is called byte-level BPE.
GPT和roberta使用的是比特级别的字符，就是0100这种，这就是他们的基础语料库，然后在基础上融合出来词进行构建词库

实例下面进行实例解析设定语料库如下
语料库: &quot;hug&quot;, &quot;pug&quot;, &quot;pun&quot;, &quot;bun&quot;, &quot;hugs&quot;
词频: (&quot;hug&quot;, 10), (&quot;pug&quot;, 5), (&quot;pun&quot;, 12), (&quot;bun&quot;, 4), (&quot;hugs&quot;, 5)
1# (&quot;h&quot; &quot;u&quot; &quot;g&quot;, 10), (&quot;p&quot; &quot;u&quot; &quot;g&quot;, 5), (&quot;p&quot; &quot;u&quot; &quot;n&quot;, 12), (&quot;b&quot; &quot;u&quot; &quot;n&quot;, 4), (&quot;h&quot; &quot;u&quot; &quot;g&quot; &quot;s&quot;, 5)



第一轮
最多的是 ug的组合，20次
123&#x27;&#x27;&#x27;Vocabulary: [&quot;b&quot;, &quot;g&quot;, &quot;h&quot;, &quot;n&quot;, &quot;p&quot;, &quot;s&quot;, &quot;u&quot;, &quot;ug&quot;]Corpus: (&quot;h&quot; &quot;ug&quot;, 10), (&quot;p&quot; &quot;ug&quot;, 5), (&quot;p&quot; &quot;u&quot; &quot;n&quot;, 12), (&quot;b&quot; &quot;u&quot; &quot;n&quot;, 4), (&quot;h&quot; &quot;ug&quot; &quot;s&quot;, 5)&#x27;&#x27;&#x27;

第二轮
最多是un
123&#x27;&#x27;&#x27;Vocabulary: [&quot;b&quot;, &quot;g&quot;, &quot;h&quot;, &quot;n&quot;, &quot;p&quot;, &quot;s&quot;, &quot;u&quot;, &quot;ug&quot;, &quot;un&quot;]Corpus: (&quot;h&quot; &quot;ug&quot;, 10), (&quot;p&quot; &quot;ug&quot;, 5), (&quot;p&quot; &quot;un&quot;, 12), (&quot;b&quot; &quot;un&quot;, 4), (&quot;h&quot; &quot;ug&quot; &quot;s&quot;, 5)&#x27;&#x27;

第三轮
最多的是hug
123&#x27;&#x27;&#x27;Vocabulary: [&quot;b&quot;, &quot;g&quot;, &quot;h&quot;, &quot;n&quot;, &quot;p&quot;, &quot;s&quot;, &quot;u&quot;, &quot;ug&quot;, &quot;un&quot;, &quot;hug&quot;]Corpus: (&quot;hug&quot;, 10), (&quot;p&quot; &quot;ug&quot;, 5), (&quot;p&quot; &quot;un&quot;, 12), (&quot;b&quot; &quot;un&quot;, 4), (&quot;hug&quot; &quot;s&quot;, 5)&#x27;&#x27;&#x27;

…如何循环到设定的词库大小
简要代码语料库
123456corpus = [    &quot;This is the Hugging Face Course.&quot;,    &quot;This chapter is about tokenization.&quot;,    &quot;This section shows several tokenizer algorithms.&quot;,    &quot;Hopefully, you will be able to understand how they are trained and generate tokens.&quot;,]



统计词频
12345678910111213141516171819from transformers import AutoTokenizerfrom collections import defaultdicttokenizer = AutoTokenizer.from_pretrained(&quot;gpt2&quot;)word_freqs = defaultdict(int)for text in corpus:    words_with_offsets = tokenizer.backend_tokenizer.pre_tokenizer.pre_tokenize_str(text)    new_words = [word for word, offset in words_with_offsets]    for word in new_words:        word_freqs[word] += 1print(word_freqs)&#x27;&#x27;&#x27;defaultdict(int, &#123;&#x27;This&#x27;: 3, &#x27;Ġis&#x27;: 2, &#x27;Ġthe&#x27;: 1, &#x27;ĠHugging&#x27;: 1, &#x27;ĠFace&#x27;: 1, &#x27;ĠCourse&#x27;: 1, &#x27;.&#x27;: 4, &#x27;Ġchapter&#x27;: 1,    &#x27;Ġabout&#x27;: 1, &#x27;Ġtokenization&#x27;: 1, &#x27;Ġsection&#x27;: 1, &#x27;Ġshows&#x27;: 1, &#x27;Ġseveral&#x27;: 1, &#x27;Ġtokenizer&#x27;: 1, &#x27;Ġalgorithms&#x27;: 1,    &#x27;Hopefully&#x27;: 1, &#x27;,&#x27;: 1, &#x27;Ġyou&#x27;: 1, &#x27;Ġwill&#x27;: 1, &#x27;Ġbe&#x27;: 1, &#x27;Ġable&#x27;: 1, &#x27;Ġto&#x27;: 1, &#x27;Ġunderstand&#x27;: 1, &#x27;Ġhow&#x27;: 1,    &#x27;Ġthey&#x27;: 1, &#x27;Ġare&#x27;: 1, &#x27;Ġtrained&#x27;: 1, &#x27;Ġand&#x27;: 1, &#x27;Ġgenerate&#x27;: 1, &#x27;Ġtokens&#x27;: 1&#125;)&#x27;&#x27;&#x27;


首先载入gpt的分词器，做预分词
再载入collection中的defaultdict设定为int类型

基础词汇表
123456789101112alphabet = []for word in word_freqs.keys():    for letter in word:        if letter not in alphabet:            alphabet.append(letter)alphabet.sort()print(alphabet)&#x27;&#x27;&#x27;[ &#x27;,&#x27;, &#x27;.&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;H&#x27;, &#x27;T&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;r&#x27;, &#x27;s&#x27;,  &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;Ġ&#x27;]&#x27;&#x27;&#x27;

加个表头vocab = [&quot;&lt;|endoftext|&gt;&quot;] + alphabet.copy()
将单词映射为{‘word’: [‘w’, ‘o’, ‘r’, ‘d’]}的形式进行训练
1234splits = &#123;word: [c for c in word] for word in word_freqs.keys()&#125;# 我觉可以改一下`splits = &#123;word: list(word) for word in word_freqs.keys()&#125;`



字母对频率函数
1234567891011121314151617181920212223242526272829303132333435363738394041def compute_pair_freqs(splits):    pair_freqs = defaultdict(int)    for word, freq in word_freqs.items():        split = splits[word]	# 取得word对应的值如[&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;d&#x27;]        if len(split) == 1:            continue        for i in range(len(split) - 1):            pair = (split[i], split[i + 1])            pair_freqs[pair] += freq	# 记录字母对的频率    return pair_freqs# 示例pair_freqs = compute_pair_freqs(splits)for i, key in enumerate(pair_freqs.keys()):    print(f&quot;&#123;key&#125;: &#123;pair_freqs[key]&#125;&quot;)    if i &gt;= 5:        break&#x27;&#x27;&#x27;(&#x27;T&#x27;, &#x27;h&#x27;): 3(&#x27;h&#x27;, &#x27;i&#x27;): 3(&#x27;i&#x27;, &#x27;s&#x27;): 5(&#x27;Ġ&#x27;, &#x27;i&#x27;): 2(&#x27;Ġ&#x27;, &#x27;t&#x27;): 7(&#x27;t&#x27;, &#x27;h&#x27;): 3&#x27;&#x27;&#x27;# 取最大值best_pair = &quot;&quot;max_freq = Nonefor pair, freq in pair_freqs.items():    if max_freq is None or max_freq &lt; freq:        best_pair = pair        max_freq = freqprint(best_pair, max_freq)# (&#x27;Ġ&#x27;, &#x27;t&#x27;) 7# 合并入库merges = &#123;(&quot;Ġ&quot;, &quot;t&quot;): &quot;Ġt&quot;&#125;vocab.append(&quot;Ġt&quot;)



将字符对构建进新的基础词表split (不是vocab)
12345678910111213141516171819def merge_pair(a, b, splits):    for word in word_freqs:        split = splits[word] # 取得word对应的值如[&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;d&#x27;]        if len(split) == 1:            continue        i = 0        while i &lt; len(split) - 1:            if split[i] == a and split[i + 1] == b:             	# 找到词对的位置，将ab字符串连接起来，做个列表存起来                split = split[:i] + [a + b] + split[i + 2 :]            else:                i += 1         splits[word] = split # 更新 [&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;d&#x27;] -&gt; [&#x27;wo&#x27;, &#x27;r&#x27;, &#x27;d&#x27;]    return splitssplits = merge_pair(&quot;Ġ&quot;, &quot;t&quot;, splits)print(splits[&quot;Ġtrained&quot;])# [&#x27;Ġt&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;e&#x27;, &#x27;d&#x27;]



构建循环
1234567891011121314151617181920vocab_size = 50while len(vocab) &lt; v ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/37742.html" title="HF Course 07 NER QA Tokenizer"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/Eris11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HF Course 07 NER QA Tokenizer"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/37742.html" title="HF Course 07 NER QA Tokenizer">HF Course 07 NER QA Tokenizer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-11T14:53:10.235Z" title="发表于 2022-12-11 22:53:10">2022-12-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T14:29:48.810Z" title="更新于 2022-12-12 22:29:48">2022-12-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Universe/">Universe</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Huggingface/">Huggingface</a></span></div><div class="content">记得排版 分割线待完成
QA部分


本章我们需要对做特殊的tokenizer以适应NER和QA任务数据的特殊性

Fast Tokenizer1234567from transformers import AutoTokenizertokenizer = AutoTokenizer.from_pretrained(&quot;bert-base-cased&quot;)example = &quot;My name is Sylvain and I work at Hugging Face in Brooklyn.&quot;encoding = tokenizer(example)print(type(encoding))# &lt;class &#x27;transformers.tokenization_utils_base.BatchEncoding&#x27;&gt;

分词后返回的结果类型不简单是字典的映射
还包含很多方法
123456789101112tokenizer.is_fast, encoding.is_fast(True,True)encoding.tokens()&#x27;&#x27;&#x27;[&#x27;[CLS]&#x27;, &#x27;My&#x27;, &#x27;name&#x27;, &#x27;is&#x27;, &#x27;S&#x27;, &#x27;##yl&#x27;, &#x27;##va&#x27;, &#x27;##in&#x27;, &#x27;and&#x27;, &#x27;I&#x27;, &#x27;work&#x27;, &#x27;at&#x27;, &#x27;Hu&#x27;, &#x27;##gging&#x27;, &#x27;Face&#x27;, &#x27;in&#x27;, &#x27;Brooklyn&#x27;, &#x27;.&#x27;, &#x27;[SEP]&#x27;]&#x27;&#x27;&#x27; encoding.word_ids()&#x27;&#x27;&#x27;[None, 0, 1, 2, 3, 3, 3, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11, 12, None]&#x27;&#x27;&#x27;

word_ids()方法可看到分词的结果来自哪个单词
最后我们可以使用word_to_chars() or token_to_chars() and char_to_word() or char_to_token() 查看单词
123start, end = encoding.word_to_chars(3)example[start:end]# Sylvain



NER
在NER中我们以偏移量的标记来锁定原文的字符

pipeline方法首先查看pipeline方法的ner流程
12345678910111213from transformers import pipelinetoken_classifier = pipeline(&quot;token-classification&quot;)token_classifier(&quot;My name is Sylvain and I work at Hugging Face in Brooklyn.&quot;)&#x27;&#x27;&#x27;[&#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9993828, &#x27;index&#x27;: 4, &#x27;word&#x27;: &#x27;S&#x27;, &#x27;start&#x27;: 11, &#x27;end&#x27;: 12&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99815476, &#x27;index&#x27;: 5, &#x27;word&#x27;: &#x27;##yl&#x27;, &#x27;start&#x27;: 12, &#x27;end&#x27;: 14&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99590725, &#x27;index&#x27;: 6, &#x27;word&#x27;: &#x27;##va&#x27;, &#x27;start&#x27;: 14, &#x27;end&#x27;: 16&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9992327, &#x27;index&#x27;: 7, &#x27;word&#x27;: &#x27;##in&#x27;, &#x27;start&#x27;: 16, &#x27;end&#x27;: 18&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.97389334, &#x27;index&#x27;: 12, &#x27;word&#x27;: &#x27;Hu&#x27;, &#x27;start&#x27;: 33, &#x27;end&#x27;: 35&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.976115, &#x27;index&#x27;: 13, &#x27;word&#x27;: &#x27;##gging&#x27;, &#x27;start&#x27;: 35, &#x27;end&#x27;: 40&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.98879766, &#x27;index&#x27;: 14, &#x27;word&#x27;: &#x27;Face&#x27;, &#x27;start&#x27;: 41, &#x27;end&#x27;: 45&#125;, &#123;&#x27;entity&#x27;: &#x27;I-LOC&#x27;, &#x27;score&#x27;: 0.99321055, &#x27;index&#x27;: 16, &#x27;word&#x27;: &#x27;Brooklyn&#x27;, &#x27;start&#x27;: 49, &#x27;end&#x27;: 57&#125;]&#x27;&#x27;&#x27;



简洁版
12345678from transformers import pipelinetoken_classifier = pipeline(&quot;token-classification&quot;, aggregation_strategy=&quot;simple&quot;)token_classifier(&quot;My name is Sylvain and I work at Hugging Face in Brooklyn.&quot;)&#x27;&#x27;&#x27;[&#123;&#x27;entity_group&#x27;: &#x27;PER&#x27;, &#x27;score&#x27;: 0.9981694, &#x27;word&#x27;: &#x27;Sylvain&#x27;, &#x27;start&#x27;: 11, &#x27;end&#x27;: 18&#125;, &#123;&#x27;entity_group&#x27;: &#x27;ORG&#x27;, &#x27;score&#x27;: 0.97960204, &#x27;word&#x27;: &#x27;Hugging Face&#x27;, &#x27;start&#x27;: 33, &#x27;end&#x27;: 45&#125;, &#123;&#x27;entity_group&#x27;: &#x27;LOC&#x27;, &#x27;score&#x27;: 0.99321055, &#x27;word&#x27;: &#x27;Brooklyn&#x27;, &#x27;start&#x27;: 49, &#x27;end&#x27;: 57&#125;]&#x27;&#x27;&#x27;

aggregation_strategy有不同的参数，simple是分词后的平均分数
如上面的sylvain分数来自 正常版的四项平均&#39;S&#39;, &#39;##yl&#39;, &#39;##va&#39;, &#39;##in&#39;

&quot;first&quot;, where the score of each entity is the score of the first token of that entity (so for “Sylvain” it would be 0.993828, the score of the token S)
&quot;max&quot;, where the score of each entity is the maximum score of the tokens in that entity (so for “Hugging Face” it would be 0.98879766, the score of “Face”)
&quot;average&quot;, where the score of each entity is the average of the scores of the words composing that entity (so for “Sylvain” there would be no difference from the &quot;simple&quot; strategy, but “Hugging Face” would have a score of 0.9819, the average of the scores for “Hugging”, 0.975, and “Face”, 0.98879)

logits这里通过返回的结果使用argmax(-1)得到映射的分类
123456789from transformers import AutoTokenizer, AutoModelForTokenClassificationmodel_checkpoint = &quot;dbmdz/bert-large-cased-finetuned-conll03-english&quot;tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)model = AutoModelForTokenClassification.from_pretrained(model_checkpoint)example = &quot;My name is Sylvain and I work at Hugging Face in Brooklyn.&quot;inputs = tokenizer(example, return_tensors=&quot;pt&quot;)outputs = model(**inputs)



12345print(inputs[&quot;input_ids&quot;].shape)print(outputs.logits.shape)&#x27;&#x27;&#x27;torch.Size([1, 19])torch.Size([1, 19, 9])&#x27;&#x27;&#x27;



123456789101112131415161718import torchprobabilities = torch.nn.functional.softmax(outputs.logits, dim=-1)[0].tolist()predictions = outputs.logits.argmax(dim=-1)[0].tolist()print(predictions)# [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 6, 6, 6, 0, 8, 0, 0]model.config.id2label&#x27;&#x27;&#x27;&#123;0: &#x27;O&#x27;, 1: &#x27;B-MISC&#x27;, 2: &#x27;I-MISC&#x27;, 3: &#x27;B-PER&#x27;, 4: &#x27;I-PER&#x27;, 5: &#x27;B-ORG&#x27;, 6: &#x27;I-ORG&#x27;, 7: &#x27;B-LOC&#x27;, 8: &#x27;I-LOC&#x27;&#125;&#x27;&#x27;&#x27;



偏移量postprocessing组织一下格式，复现上面的内容
123456789101112131415161718192021results = []tokens = inputs.tokens()for idx, pred in enumerate(predictions):    label = model.config.id2label[pred]    if label != &quot;O&quot;:        results.append(            &#123;&quot;entity&quot;: label, &quot;score&quot;: probabilities[idx][pred], &quot;word&quot;: tokens[idx]&#125;        )print(results)&#x27;&#x27;&#x27;[&#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9993828, &#x27;index&#x27;: 4, &#x27;word&#x27;: &#x27;S&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99815476, &#x27;index&#x27;: 5, &#x27;word&#x27;: &#x27;##yl&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99590725, &#x27;index&#x27;: 6, &#x27;word&#x27;: &#x27;##va&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9992327, &#x27;index&#x27;: 7, &#x27;word&#x27;: &#x27;##in&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.97389334, &#x27;index&#x27;: 12, &#x27;word&#x27;: &#x27;Hu&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.976115, &#x27;index&#x27;: 13, &#x27;word&#x27;: &#x27;##gging&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-ORG&#x27;, &#x27;score&#x27;: 0.98879766, &#x27;index&#x27;: 14, &#x27;word&#x27;: &#x27;Face&#x27;&#125;, &#123;&#x27;entity&#x27;: &#x27;I-LOC&#x27;, &#x27;score&#x27;: 0.99321055, &#x27;index&#x27;: 16, &#x27;word&#x27;: &#x27;Brooklyn&#x27;&#125;]&#x27;&#x27;&#x27;



偏移量 offsets_mapping
123456inputs_with_offsets = tokenizer(example, return_offsets_mapping=True)inputs_with_offsets[&quot;offset_mapping&quot;]&#x27;&#x27;&#x27;[(0, 0), (0, 2), (3, 7), (8, 10), (11, 12), (12, 14), (14, 16), (16, 18), (19, 22), (23, 24), (25, 29), (30, 32), (33, 35), (35, 40), (41, 45), (46, 48), (49, 57), (57, 58), (0, 0)]&#x27;&#x27;&#x27;

这里的19对元组就是对应19个分词后token的下标
1[&#x27;[CLS]&#x27;, &#x27;My&#x27;, &#x27;name&#x27;, &#x27;is&#x27;, &#x27;S&#x27;, &#x27;##yl&#x27;, &#x27;##va&#x27;, &#x27;##in&#x27;, &#x27;and&#x27;, &#x27;I&#x27;, &#x27;work&#x27;, &#x27;at&#x27;, &#x27;Hu&#x27;, &#x27;##gging&#x27;, &#x27;Face&#x27;, &#x27;in&#x27;,&#x27;Brooklyn&#x27;, &#x27;.&#x27;, &#x27;[SEP]&#x27;]

比如(0,0)是留给[CLS]的；	比如第六个token对应的是 ##ly  那么他在原文中的标注就是（12,14），如下
12example[12:14]# yl



继续我们的复现pipeline
123456789101112131415161718192021222324252627282930results = []inputs_with_offsets = tokenizer(example, return_offsets_mapping=True)tokens = inputs_with_offsets.tokens()offsets = inputs_with_offsets[&quot;offset_mapping&quot;]for idx, pred in enumerate(predictions):    label = model.config.id2label[pred]    if label != &quot;O&quot;:        start, end = offsets[idx]        results.append(            &#123;                &quot;entity&quot;: label,                &quot;score&quot;: probabilities[idx][pred],                &quot;word&quot;: tokens[idx],                &quot;start&quot;: start,                &quot;end&quot;: end,            &#125;        )print(results)&#x27;&#x27;&#x27;[&#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9993828, &#x27;index&#x27;: 4, &#x27;word&#x27;: &#x27;S&#x27;, &#x27;start&#x27;: 11, &#x27;end&#x27;: 12&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99815476, &#x27;index&#x27;: 5, &#x27;word&#x27;: &#x27;##yl&#x27;, &#x27;start&#x27;: 12, &#x27;end&#x27;: 14&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.99590725, &#x27;index&#x27;: 6, &#x27;word&#x27;: &#x27;##va&#x27;, &#x27;start&#x27;: 14, &#x27;end&#x27;: 16&#125;, &#123;&#x27;entity&#x27;: &#x27;I-PER&#x27;, &#x27;score&#x27;: 0.9992327, &#x27;index&#x27;: 7, &#x27;word&#x27;: &#x27;##in&#x27;, &#x27;start&#x27;: 16, &#x27;end&#x27;: 18&#125;, &#123;&#x27;entity&#x27;: &#x ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/55913.html" title="HF Course 06 继承式的Tokenizer"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/Eris11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HF Course 06 继承式的Tokenizer"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/55913.html" title="HF Course 06 继承式的Tokenizer">HF Course 06 继承式的Tokenizer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-11T13:27:56.158Z" title="发表于 2022-12-11 21:27:56">2022-12-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-12T14:28:18.936Z" title="更新于 2022-12-12 22:28:18">2022-12-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Universe/">Universe</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Huggingface/">Huggingface</a></span></div><div class="content">这种方法是基于旧的模型分词器上，针对你的语料库训练一个新的分词器的方法。夺舍属于是
这里我们以GPT的分词器为例，它使用unigram的算法进行分词
载入数据12345678910111213from datasets import load_dataset# This can take a few minutes to load, so grab a coffee or tea while you wait!raw_datasets = load_dataset(&quot;code_search_net&quot;, &quot;python&quot;)raw_datasets[&quot;train&quot;]&#x27;&#x27;&#x27;Dataset(&#123;    features: [&#x27;repository_name&#x27;, &#x27;func_path_in_repository&#x27;, &#x27;func_name&#x27;, &#x27;whole_func_string&#x27;, &#x27;language&#x27;,       &#x27;func_code_string&#x27;, &#x27;func_code_tokens&#x27;, &#x27;func_documentation_string&#x27;, &#x27;func_documentation_tokens&#x27;, &#x27;split_name&#x27;,       &#x27;func_code_url&#x27;    ],    num_rows: 412178&#125;)&#x27;&#x27;&#x27;



生成器加载数据下面的方法会一次加载所有数据
12# Don&#x27;t uncomment the following line unless your dataset is small!# training_corpus = [raw_datasets[&quot;train&quot;][i: i + 1000][&quot;whole_func_string&quot;] for i in range(0, len(raw_datasets[&quot;train&quot;]), 1000)]



一般使用python生成器
1234training_corpus = (    raw_datasets[&quot;train&quot;][i : i + 1000][&quot;whole_func_string&quot;]    for i in range(0, len(raw_datasets[&quot;train&quot;]), 1000))

将列表推导式的方括号换成圆括号就可以变成生成器了，好厉害。

123456&gt;gen = (i for i in range(10))&gt;print(list(gen))&gt;print(list(gen))&gt;&#x27;&#x27;&#x27;&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;[]&#x27;&#x27;&#x27;

使用之后会清空内存，如上所示

更一般的生成器
12345def get_training_corpus():    dataset = raw_datasets[&quot;train&quot;]    for start_idx in range(0, len(dataset), 1000):        samples = dataset[start_idx : start_idx + 1000]        yield samples[&quot;whole_func_string&quot;]



train_new_from_iterator()载入模型1234567891011121314from transformers import AutoTokenizerold_tokenizer = AutoTokenizer.from_pretrained(&quot;gpt2&quot;)example = &#x27;&#x27;&#x27;def add_numbers(a, b):    &quot;&quot;&quot;Add the two numbers `a` and `b`.&quot;&quot;&quot;    return a + b&#x27;&#x27;&#x27;tokens = old_tokenizer.tokenize(example)tokens&#x27;&#x27;&#x27;[&#x27;def&#x27;, &#x27;Ġadd&#x27;, &#x27;_&#x27;, &#x27;n&#x27;, &#x27;umbers&#x27;, &#x27;(&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;Ġb&#x27;, &#x27;):&#x27;, &#x27;Ċ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġ&quot;&quot;&quot;&#x27;, &#x27;Add&#x27;, &#x27;Ġthe&#x27;, &#x27;Ġtwo&#x27;, &#x27;Ġnumbers&#x27;, &#x27;Ġ`&#x27;, &#x27;a&#x27;, &#x27;`&#x27;, &#x27;Ġand&#x27;, &#x27;Ġ`&#x27;, &#x27;b&#x27;, &#x27;`&#x27;, &#x27;.&quot;&#x27;, &#x27;&quot;&quot;&#x27;, &#x27;Ċ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġ&#x27;, &#x27;Ġreturn&#x27;, &#x27;Ġa&#x27;, &#x27;Ġ+&#x27;, &#x27;Ġb&#x27;]&#x27;&#x27;&#x27;

This tokenizer has a few special symbols, like Ġ and Ċ, which denote spaces and newlines, respectively。
两个G表示空格和换行符。他还为多个空格在一起的单独编码，带下划线的词也不认识，所以不太合适。
训练新分词器1tokenizer = old_tokenizer.train_new_from_iterator(training_corpus, 52000)


注意，只有Fast的tokenizer支持train_new_from_iterator方法，他们是根据rust写的。没有fast的是纯python写的。

12345tokens = tokenizer.tokenize(example)tokens&#x27;&#x27;&#x27;[&#x27;def&#x27;, &#x27;Ġadd&#x27;, &#x27;_&#x27;, &#x27;numbers&#x27;, &#x27;(&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;Ġb&#x27;, &#x27;):&#x27;, &#x27;ĊĠĠĠ&#x27;, &#x27;Ġ&quot;&quot;&quot;&#x27;, &#x27;Add&#x27;, &#x27;Ġthe&#x27;, &#x27;Ġtwo&#x27;, &#x27;Ġnumbers&#x27;, &#x27;Ġ`&#x27;, &#x27;a&#x27;, &#x27;`&#x27;, &#x27;Ġand&#x27;, &#x27;Ġ`&#x27;, &#x27;b&#x27;, &#x27;`.&quot;&quot;&quot;&#x27;, &#x27;ĊĠĠĠ&#x27;, &#x27;Ġreturn&#x27;, &#x27;Ġa&#x27;, &#x27;Ġ+&#x27;, &#x27;Ġb&#x27;]&#x27;&#x27;&#x27;

起码多个空格学会了
存储新分词器1tokenizer.save_pretrained(&quot;code-search-net-tokenizer&quot;)

</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/poyone1222/eris/eris11.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Poy One</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/poyone"><i></i><span>🛴前往github...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/poyone" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:poyone1222@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客 <br> QQ 914987163</div></div><div class="sticky_layout"><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">27</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">49.9k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-12-15T14:44:59.079Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Poy One</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/light.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka15.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CV/&quot;);" href="javascript:void(0);">CV</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">计算机视觉</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/NLP/&quot;);" href="javascript:void(0);">NLP</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">自然语言处理</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka10.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Trick/&quot;);" href="javascript:void(0);">Trick</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">import torch as tf</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Dive-Into-Paper/&quot;);" href="javascript:void(0);">Dive Into Paper</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">论文精读</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka16.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Python/&quot;);" href="javascript:void(0);">Python</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">流畅的Python</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/poyone1222/Asuka/Asuka32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Universe/&quot;);" href="javascript:void(0);">Universe</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr">拥有一切 却变成太空</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>